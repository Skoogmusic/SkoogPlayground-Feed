<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - interactive - cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>html, body {position: fixed;  overflow-x: hidden; 
    overflow-y: hidden;}</style>
	</head>
	<body>


        
		<script src="tween.js"></script>
		<script src="three.js"></script>
		<script src="Projector.js"></script>
		<script src="CanvasRenderer.js"></script>
<!--		<script src="stats.min.js"></script>-->
  
        

        <script>
            var container;
			var camera, scene, renderer,sideParent;
			var particleMaterial;
			var raycaster;
			var mouse;
			var objects = [];
            var sides = []; 
            var sideStates=[false,false,false,false,false];
            var sideSizes=[false,false,false,false,false];


            var frames = [];
            var idleRotation=false;
            var maxH=1;
            var baseHeight=0.5;
            var wireFrame=true;
            var parentObj;
            var info;
            var mouseX, mouseY;

            var notes = [new Audio('red.wav'),
                       new Audio('blue.wav'),
                       new Audio('yellow.wav'),
                       new Audio('green.wav'),
                       new Audio('orange.wav')];

			window.onload = init;
            Function.prototype.bind = function(parent) {
                var f = this;
                var args = [];

                for (var a = 1; a < arguments.length; a++) {
                    args[args.length] = arguments[a];
                }

                var temp = function() {
                return f.apply(parent, args);
                };
                return(temp);
            };                  
   
    /////------

            
             function growSide(index, grow){
                 if(sideStates[index]){

                 if(grow&&!sideSizes[index]){

                    new TWEEN.Tween(sides[index].material)
                    .to( {linewidth: 30}, 50)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
                    sideSizes[index]=true;

                     } else if(!grow&&sideSizes[index]){

                new TWEEN.Tween(sides[index].material)
                                .to( {linewidth: 15}, 20)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();
                                sideSizes[index]=false;

                    }
             }
            };
            
            
            function spinSkoog(direction, time){
                new TWEEN.Tween( parentObj.rotation)
                    .to( { y:THREE.Math.degToRad( direction*45)}, time )
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
            };
            
             function ySpin (direction,time){
                 new TWEEN.Tween( parentObj.rotation )
                    .to( { y: parentObj.rotation.y+(direction*0.5*Math.PI)}, time )
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();    
             };
            
            function zSpin (direction,time){
                new TWEEN.Tween( parentObj.rotation )
                    .to( { z: parentObj.rotation.z+(direction*0.5*Math.PI)}, time )
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
            };

            function xSpin (direction,time){
                new TWEEN.Tween( parentObj.rotation )
                    .to( { x: parentObj.rotation.x+(direction*0.5*Math.PI)}, time )
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
            };
            
            function panCam(time){
                new TWEEN.Tween (camera.position) 
                    .to({x:0,y:6,z:9},time)
                    .easing(TWEEN.Easing.Quintic.In)
                    .start();
              camera.updateProjectionMatrix();
            }
            
            function removeEntity(object,parent) {
                var selectedObject = parent.getObjectByName(object);
                parent.remove( selectedObject );
            }

  
            
            

 
            
    //////////////////////////////////////////////////////////////////////////////////
	//		RAYCAST SIDE DRAW						//
	//////////////////////////////////////////////////////////////////////////////////

            
        function sideDetectDraw(coordIndex){
                    var xCoords = [-1,0,1,0,0];
                    var yCoords = [0,0,0,0,1];
                    var zCoords = [0, -1, 0, 1,0];
                    var colours = [0xf32837,0x005195,0xfee000,0x3d9b35,0xff5a00,0x747679];
                    var xRotations = [ 0, 0,0,0,0.5*Math.PI];
                    var yRotations = [ 0.5*Math.PI, 0, 0.5*Math.PI,0,0];
                
                    var sideDetects = [];
            
                    var geometry = new THREE.BoxGeometry( 1.9, 1.9, 0.01);

                
                     
                    var names = ['redRay','blueRay','yellowRay','greenRay','orangeRay'];
                    
                    var material =  new THREE.MeshBasicMaterial( { color: colours[coordIndex], opacity: 0} );
                    material.depthWrite = true;
                    

					var object = new THREE.Mesh( geometry, material );
                
                    object.position.x = xCoords[coordIndex];
                    object.position.y = yCoords[coordIndex]+maxH;
                    object.position.z = zCoords[coordIndex];


					object.scale.x = 1;
					object.scale.y = 1;
					object.scale.z = 1;
					object.rotation.x =xRotations[coordIndex];
                    object.rotation.y =yRotations[coordIndex];
                    
                    parentObj.add(object);
                    object.name= names[coordIndex] ;
                    sideDetects[coordIndex]=object;
					objects.push( object );
        }     
            
    //////////////////////////////////////////////////////////////////////////////////
	//		CIRCLE DRAW						//
	//////////////////////////////////////////////////////////////////////////////////	
            var segmentCount = 60;
            radius = 0.5;

            var redMat = new THREE.LineBasicMaterial( { color: 0xf32837,linewidth: 15} ) ;
            var yellowMat = new THREE.LineBasicMaterial( { color:0xfee000 ,linewidth: 15} ) ;
            var orangeMat = new THREE.LineBasicMaterial( { color:0xff5a00 ,linewidth: 15} ) ;
            var greenMat = new THREE.LineBasicMaterial( { color: 0x3d9b35,linewidth: 15} ) ;
            var blueMat = new THREE.LineBasicMaterial( { color: 0x005195,linewidth: 15} ) ;
            
         
            
            function circleDraw(name, material, coordIndex){
                geometry = new THREE.Geometry();

                for (var i = 0; i <= segmentCount; i++) {
                    var theta = (i / segmentCount) * Math.PI * 2;
                    var circleCoords=  [new THREE.Vector3(-1,(Math.sin(theta) * radius)+maxH,Math.cos(theta) * radius), //RED
                                        new THREE.Vector3((Math.sin(theta) * radius),(Math.cos(theta) * radius)+maxH,-1), //BLUE
                                        new THREE.Vector3(1,(Math.sin(theta) * radius)+maxH,Math.cos(theta) * radius), //YELLOW
                                        new THREE.Vector3(Math.sin(theta) * radius,(Math.cos(theta) * radius)+maxH,1), //GREEN
                                        new THREE.Vector3(Math.sin(theta) * radius,1+maxH,Math.cos(theta) * radius) //ORANGE
                                        ];
                    geometry.vertices.push(circleCoords[coordIndex]);  
                };

                object=new THREE.Line(geometry, material);
                object.name= name;
                sideParent.add(object);
                sides[coordIndex]=object;
//                sides.push( object );   
                sideStates[coordIndex]=true;
            };       
            
            
          
    //////////////////////////////////////////////////////////////////////////////////
	//		INIT						//
	//////////////////////////////////////////////////////////////////////////////////	
            

            function init() {


				container = document.createElement( 'div' );
                container.className = 'virtualSkoog';
				document.body.appendChild( container );
				info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				container.appendChild( info );
         
                
                camera = new THREE.PerspectiveCamera( 30, window.innerWidth/window.innerHeight, 0.1, 1000 );
                camera.position.set( 0, +maxH, 10 ); //reset  to 0,20,0


				scene = new THREE.Scene();
                camera.lookAt(scene.position);  

                material1 = new THREE.MeshBasicMaterial({ color: 0xfff000, opacity:0 });
                material2 = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity:0 });

                parentObj = new THREE.Mesh(new THREE.CubeGeometry(0  , 0, 0), material2);
                                scene.add(parentObj);

                sideParent = new THREE.Mesh(new THREE.CubeGeometry(0, 0, 0), material1);
                scene.rotation.z=2*Math.PI;
                scene.rotation.y=0.5*Math.PI;

     

                sideParent.name='sideParent';
                parentObj.add(sideParent);

                //SET length of side array
                for(var i = 0; i < 5; i++) {
                    sides.push(new THREE.Mesh(new THREE.CubeGeometry(2, 2, 2), material1));
                }
                wireFrame=true;

                
                
                var sideMaterials = [];
                
                for(var i=0; i<6;i++){
                 sideMaterials.push(new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 10} ));   
                }
                
                new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 10} ) ;        
                
                    //RED
                var geometry = new THREE.Geometry();
                var vertices = [new THREE.Vector3(-1,1+maxH,1),new THREE.Vector3(-1,-1+maxH,1),new THREE.Vector3(-1,-1+maxH,-1),new THREE.Vector3(-1,1+maxH,-1),new THREE.Vector3(-1,1+maxH,1)];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[0]);
                parentObj.add(object);
                frames.push(object);
                
                
                 ///BLUE
                var geometry = new THREE.Geometry();
                var vertices = [ new THREE.Vector3(-1,1+maxH,-1),new THREE.Vector3(-1,-1+maxH,-1),
                                new THREE.Vector3(1,-1+maxH,-1),new THREE.Vector3(1,1+maxH,-1),new THREE.Vector3(-1,1+maxH,-1),];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[1]);
                parentObj.add(object);

                frames.push(object);
                
                
                //YELLOW
                var geometry = new THREE.Geometry();
                var vertices = [new THREE.Vector3(1,1+maxH,-1),new THREE.Vector3(1,1+maxH,1),new THREE.Vector3(1,-1+maxH,1),new THREE.Vector3(1,-1+maxH,-1),new THREE.Vector3(1,1+maxH,-1)];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[2]);
                parentObj.add(object);

                frames.push(object);
                
                
                
                ///GREEN
                var geometry = new THREE.Geometry();
                var vertices = [new THREE.Vector3(-1,1+maxH,1),new THREE.Vector3(1,1+maxH,1),new THREE.Vector3(1,-1+maxH,1),new THREE.Vector3(-1,-1+maxH,1),new THREE.Vector3(-1,1+maxH,1)];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[3]);
                parentObj.add(object);

                frames.push(object);
                
                
                 //ORANGE
                var geometry = new THREE.Geometry();
                var vertices = [new THREE.Vector3(-1,1+maxH,1),new THREE.Vector3(1,1+maxH,1),new THREE.Vector3(1,1+maxH,-1),new THREE.Vector3(-1,1+maxH,-1),new THREE.Vector3(-1,1+maxH,1)];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[4]);
                parentObj.add(object);

                frames.push(object);
                
                
                ///GREEN
                var geometry = new THREE.Geometry();
                var vertices = [new THREE.Vector3(-1,1+maxH,1),new THREE.Vector3(1,1+maxH,1),new THREE.Vector3(1,-1+maxH,1),new THREE.Vector3(-1,-1+maxH,1),new THREE.Vector3(-1,1+maxH,1)];
                for(var i = 0; i< vertices.length; i++){
                geometry.vertices.push(vertices[i]);
                    
                }
                var object = new THREE.Line(geometry, sideMaterials[3]);
                parentObj.add(object);

                frames.push(object);
                
                
   
                
            ///////--------------------Animations Start 
                setTimeout(function() {circleDraw('red',redMat,0)}.bind(this), 0);
                setTimeout(function() {circleDraw('green',greenMat,3)}.bind(this), 1000);
                setTimeout(function() {circleDraw('orange',orangeMat,4)}.bind(this), 2800);
                setTimeout(function() {sideDetectDraw(0)}.bind(this), 0);
                setTimeout(function() {sideDetectDraw(3)}.bind(this), 0);
                setTimeout(function() {sideDetectDraw(4)}.bind(this), 0);


                setTimeout(function() {panCam(1000)}.bind(this), 2000);
                setTimeout(function(){spinSkoog(-1,1000)}.bind(this),1000);

                
                setTimeout(function(){wireFrame=false}.bind(this),1000);
                
                setTimeout(function(){ignoreTouches=false}.bind(this),3000);
                setTimeout(function(){idleRotation=true}.bind(this),3000);
                
                
            ///////--------------------Animations End 


				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
                
//                stats = new Stats();
//                container.appendChild( stats.dom );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
                document.addEventListener( 'touchend', onDocumentTouchEnd, false );
                document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			
            animate();
          

            }
            

  
            
            
            var ignoreTouches=true;
            var mouseState;
            var lastTouched;
            var lastTouchX;
            var deltaTouchX;
            var lastTouched=0;
            
        
            function onDocumentMouseDown( event ) {
                if(!ignoreTouches){
                    mouseState=true;
                    idleRotation = false;
                    lastTouchX=event.clientX; 
                    event.preventDefault();
                    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                    document.addEventListener( 'mouseout', onDocumentMouseOut, false );

                    mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
                    raycaster.setFromCamera( mouse, camera );



                        var intersects = raycaster.intersectObjects( objects );
                    if (intersects.length > 0 ) {
                        intersects[0].object.material.opacity=0;


                        var sideindex;
                        if(intersects[0].object.name == 'redRay'){
                            n = notes[0];
                            lastTouched=0;
                            n.currentTime=0;

                            growSide(0, true);


                        } else if(intersects[0].object.name == 'blueRay'){
                            n = notes[1];
                            n.currentTime=0;
                            lastTouched=1;
                            growSide(1, true);


                        }else if(intersects[0].object.name == 'yellowRay'){
                            n = notes[2];
                            n.currentTime=0;
                            lastTouched=2;
                            growSide(2, true);


                        }else if(intersects[0].object.name == 'greenRay'){
                            n = notes[3];
                            n.currentTime=0;  
                            lastTouched=3;
                            growSide(3, true);



                        }else if(intersects[0].object.name == 'orangeRay'){
                            n = notes[4];
                            n.currentTime=0;
                            lastTouched=4;
                            growSide(4, true);
                        }
                        n.play();
                    }
                }
            }
            
            
            var timeout;

			function onDocumentMouseMove( event ) {
                if(!ignoreTouches){

                    if(mouseState){
                        deltaTouchX = lastTouchX- event.clientX;
                        lastTouchX=event.clientX;
                        clearTimeout(timeout);
                        timeout = setTimeout(function(){deltaTouchX=0;}, 10);
                    }
                }
			}
            
        
			function onDocumentMouseUp( event ) {
                if(!ignoreTouches){
                    mouseState=false;

                    if(sideStates[lastTouched]){
                        setTimeout(function(){growSide(lastTouched,false)}.bind(this),50);
                    }
  
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false);
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false);
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false);
                }
			}
            
			function onDocumentMouseOut( event ) {
                if(!ignoreTouches){
                    mouseState=false;
                    document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                    document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                    document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
                }
			}
            
            
			function onDocumentTouchStart( event ) {
                if(!ignoreTouches){
                    idleRotation = false;
				    if ( event.touches.length == 1 ) {
                        lastTouchX=event.touches[0].clientX; 
				        event.preventDefault();
				    }
                
                
                    mouse.x = ( event.touches[0].clientX / renderer.domElement.clientWidth ) * 2 - 1;
                    mouse.y = - ( event.touches[0].clientY / renderer.domElement.clientHeight ) * 2 + 1;
                    raycaster.setFromCamera( mouse, camera );
                    var intersects = raycaster.intersectObjects( objects );

                    if (intersects.length > 0) {

                        var sideindex;

                        if(intersects[0].object.name == 'redRay'){
                            n = notes[0];
                            lastTouched=0;
                            n.currentTime=0;

                            growSide(0, true);


                        } else if(intersects[0].object.name == 'blueRay'){
                            n = notes[1];
                            n.currentTime=0;
                            lastTouched=1;
                            growSide(1, true);


                        }else if(intersects[0].object.name == 'yellowRay'){
                            n = notes[2];
                            n.currentTime=0;
                            lastTouched=2;
                            growSide(2, true);


                        }else if(intersects[0].object.name == 'greenRay'){
                            n = notes[3];
                            n.currentTime=0;  
                            lastTouched=3;
                            growSide(3, true);



                        }else if(intersects[0].object.name == 'orangeRay'){
                            n = notes[4];
                            n.currentTime=0;
                            lastTouched=4;
                            growSide(4, true);
                        }
                        n.play();
                    }
                }
			}
      
			function onDocumentTouchMove( event ) {
                if(!ignoreTouches){

                    mouseState=true;                
                    idleRotation = false;
				    if ( event.touches.length == 1 ) {
                        event.preventDefault();
                        deltaTouchX = lastTouchX- event.touches[0].clientX;
                        lastTouchX=event.touches[0].clientX;
                        clearTimeout(timeout);
                        timeout = setTimeout(function(){deltaTouchX=0;}, 10);
				    }
                } else{
                    
                }
			}
        
            function onDocumentTouchEnd (event){
                if(sideStates[lastTouched]){
                setTimeout(function(){growSide(lastTouched,false)}.bind(this),50);
                }
                if(!ignoreTouches){
                     mouseState=false;
                }
            }

         
			function animate() {
				requestAnimationFrame( animate );
                TWEEN.update();
				render();
//                stats.update();   
			}
 
           
            
            
            function render() {
                if(mouseState&&deltaTouchX){
                    parentObj.rotation.y -= deltaTouchX*0.008;
                }
             
                var eulerRotation = ((parentObj.rotation.y)*(180/Math.PI))%360;

                
           //Limit Euler angles to 0 - 360 range             
             if(eulerRotation<0){
                 eulerRotation=360-Math.abs(eulerRotation);

             }  
                
            if(!wireFrame){
                
                var leeway = 8;
                var edgeLeeway = 6;
                

                if (eulerRotation>180+leeway&&eulerRotation<360-leeway){
                       if(!sides[3]){
                            circleDraw('green',greenMat,3);
                           sideDetectDraw(3);
                        }

                    } else {                                  
                        growSide(3, false);
                        removeEntity('green',sideParent);
                        removeEntity('greenRay',parentObj);

                        sides[3]=false;
                    }
                    
                
                     if (eulerRotation>270+leeway||eulerRotation<90-leeway){
                       if(!sides[0]){
                            circleDraw('red',redMat,0);
                           sideDetectDraw(0);
                        }

                    } else {
                                                           
                        growSide(0, false);
                        removeEntity('redRay',parentObj);

                        removeEntity('red',sideParent);
                        sides[0]=false;
       
                    }
                    
                    
                    if (eulerRotation>0+leeway&&eulerRotation<180-leeway){
                       if(!sides[1]){
                            circleDraw('blue',blueMat,1);
                            sideDetectDraw(1);

                        }

                    } else {                                       
                        growSide(1, false);
                        removeEntity('blueRay',parentObj);

                        removeEntity('blue',sideParent);
                        sides[1]=false;
                    }
                
                
                    if (eulerRotation>90+leeway&&eulerRotation<270-leeway){
                       if(!sides[2]){
                            circleDraw('yellow',yellowMat,2);
                            sideDetectDraw(2);

                        }
                    } else {                                                           
                        growSide(2, false);
                        removeEntity('yellowRay',parentObj);

                        removeEntity('yellow',sideParent);
                        sides[2]=false;
                    }
                
                /////// Edge Render
                
                    if (eulerRotation>180+edgeLeeway&&eulerRotation<360-edgeLeeway){
                       frames[3].material.opacity=1;
                        frames[3].material.needsUpdate = true;

                    } else {                                  
                          frames[3].material.opacity=0;
                        frames[3].material.needsUpdate = true;
                    }
                
                    if (eulerRotation>270+edgeLeeway||eulerRotation<90-edgeLeeway){
                             frames[0].material.opacity=1;
                        frames[0].material.needsUpdate = true;

                    } else {
                                                           
                            frames[0].material.opacity=0;
                        frames[0].material.needsUpdate = true;
                    }
                    
                    if (eulerRotation>0+edgeLeeway&&eulerRotation<180-edgeLeeway){
                           frames[1].material.opacity=1;
                        frames[1].material.needsUpdate = true;

                    } else {                                       
                     frames[1].material.opacity=0;
                        frames[1].material.needsUpdate = true;

                    }
                
                    if (eulerRotation>90+edgeLeeway&&eulerRotation<270-edgeLeeway){
                       frames[2].material.opacity=1;
                        frames[2].material.needsUpdate = true;

                    } else {                                                           
                       frames[2].material.opacity=0;
                        frames[2].material.needsUpdate = true;

                    }
                
                
                       }
                
     
                
                
                
                eulerRotation= (eulerRotation+135)%360;

                
                

              
                
                if(idleRotation){
                    parentObj.rotation.y += 0.003;
                }
         
                camera.lookAt( scene.position );
				renderer.render( scene, camera );
			}
                
            
     
		</script>
	</body>
</html>